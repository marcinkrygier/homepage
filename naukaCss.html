<!DOCTYPE html>
<html lang="pl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <link href="normalize.css" rel="stylesheet" type="text/css" />
    <link href="style.css" rel="stylesheet" type="text/css" />
  </head>

  <body>
    <header>
      <nav>
        <a href="index.html">STRONA GŁÓWNA</a>
        <a href="nauka-html.html">NAUKA HTML</a>
        <a href="naukaJS.html">NAUKA JS</a>
        <a href="naukaCss.html">NAUKA CSS</a>
      </nav>
    </header>
    <main class="css__main">
      <header id="top">
        <h1  class="css__header">NAUKA CSS</h1>
      </header>
      <section  class="css__about">
        <h2  class="css__heading">FLEXBOX</h2>
        <p  class="css__description">justify-content, właściwości która wyrównuje elementy w poziomie i przyjmuje wartości<br>
          flex-start: Elementy wyrównują się do lewej strony kontenera.<br>
          flex-end: Elementy wyrównują się do prawej strony kontenera.<br>
          center: Elementy wyrównują się do środka kontenera.<br>
          space-between: Elementy wyświetlają się na całej szerokości kontenera z równymi odstępami.<br>
          space-around: Każdy z elementów wyświetla się z taką samą ilością przestrzeni wokół.<br>
          Na przykład: justify-content: flex-end; przesunie żabę do prawej strony.<br><br>
          
          align-items Ta właściwość CSS wyrównuje elementy w pionie i przyjmuje wartości:<br>
          flex-start: Elementy wyrównują się do górnej krawędzi kontenera.<br>
          flex-end: Elementy wyrównują się do dolnej krawędzi kontenera.<br>
          center: Elementy zostaną wyśrodkowane w pionie.<br><br>
          baseline: Elementy zostaną wyświetlone na linii odniesienia kontenera.<br>
          stretch: Elementy zostaną powiększone tak, aby wypełnić kontener.<br><br>
          
          flex-direction. Określa ona kierunek w jakim elementy są rozmieszczone w kontenerze i przyjmuje wartości:<br>
          row: Elementy zostaną rozmieszczone tak jak tekst.<br>
          row-reverse: Elementy zostaną rozmieszczone odwrotnie do kierunku tekstu.<br>
          column: Elementy zostaną rozmieszczone od góry do dołu.<br>
          column-reverse: Elementy zostaną rozmieszczone od dołu do góry.<br><br>
          
          Zauważ, że w przypadku gdy flex direction ma wartość column to justify-content wyrównuje element pionowo, a align-items poziomo.<br>
          
          Czasami odwracanie wierszy i kolumn kontenera nie wystarcza. W takich przypadkach, możemy zastosować własność order do pojedynczego elementu. Domyślnie elementy mają wartość 0, ale przy pomocy tej własności możemy ustalić kolejność na dowolną dodatnią lub ujemną wartość.<br>
          <br>
          align-self. Przyjmuje ona wartości takie same jak align-items, ale ma zastosowanie tylko wobec konkretnego elementu. <br>
          #pond {<br>
          display: flex;<br>
            align-items: flex-start;<br>
          }<br>
          .yellow {<br><br>
          
          flex-wrap, która przyjmuje wartości:<br>
          nowrap: Każdy element dopasowuje się do pojedynczego wiersza.<br>
          wrap: Elementy wystające przechodzą do kolejnych linii.<br>
          wrap-reverse: Elementy wystające do kolejnych linii w odwrotnej kolejności.<br><br>
          
          Jednoczesne zastosowanie własności flex-direction i flex-wrap występuje bardzo często, dlatego też utworzono własność skrótową flex-flow. Przyjmuje ona dwie wartości rozdzielone spacją.<br>
          Na przykład: wpisując flex-flow: row wrap uzyskamy efekt ułożenia elementów w wierszu i zawijanie ich do kolejnych linii w przypadku gdy któryś wystawałby poza kontener.<br><br>
          
          align-content pomoże ci ustalić odległość wierszy kontenera od siebie. Własność ta przyjmuje takie wartości:<br>
          flex-start: Wiersze upychają u góry kontenera.<br>
          flex-end: Wiersze upychają się w dolnej części kontenera.<br>
          center: Wiersze upychane są pośrodku kontenera.<br>
          space-between: Wiersze wyświetlane są z równymi odstępami.<br>
          space-around: Wiersze wyświetlane są z równymi odstępami dookoła.<br>
          stretch: Wiersze rozszerzają się tak, aby dopasować się do kontenera.<br>
          Może to być trochę pogmatwane ale align-content określa odstępy między wierszami podczas, gdy align-items określa jak elementy, jako całość, wyrównują się względem kontenera. W przypadku, gdy jest tylko jedna linia, align-content nie przynosi żadnego efektu.</p>
      </section>
      <section class="css__about"></section>
        <h2 class="css__heading">GRID</h2>
        <p  class="css__description"> grid-column-start: 3; nawodnij obszar zaczynający się od trzeciej pionowej linii, co jest innym sposobem na powiedzenie trzecia od lewej pionowa granica.<br>
          Jednakże, możesz rozszerzyć element na wiele kolumn dodając właściwość grid-column-end.<br>
          Kiedy używasz razem grid-column-start i grid-column-end, możesz zakładać że końcowa wartość musi być większa od początkowej. Ale okazuje się, że to nieprawda!<br><br>
          
          Jeżeli chcesz liczyć linie od prawej zamiast od lewej, możesz ustawić wartości grid-column-start i grid-column-end na negatywne. Na przykład, możesz ustawić wartość na -1 aby wybrać pierwszą linię od prawej.<br>
          Wpisywanie obu grid-column-start i grid-column-end za każdym razem, może być męczące. Na szczęście, grid-column jest skróconą właściwością, która akceptuje obie wartości naraz, rozdzielone przez ukośnik.<br><br>
          Na przykład, grid-column: 2 / 4;
          
          Jedną z rzeczy, która rozróżnia CSS grid od flexboxa jest to, że możesz w łatwy sposób ustawiać elementy w dwóch wymiarach: kolumnach i wierszach. grid-row-start działa podobnie jak grid-column-start z wyjątkiem osi pionowej.<br><br>
          
          Jeżeli pisanie obu grid-column i grid-row to dla ciebie za dużo, istnieje skrócona wersja tych właściwości. grid-area akceptuje cztery wartości rozdzielone przez ukośnik: grid-row-start, grid-column-start, grid-row-end oraz grid-column-end.<br>
          Jednym z przykładów jest grid-area: 1 / 1 / 3 / 6;.<br>
          m właściwości order, co jest jedną z zalet układu grid nad układem tabl<br>
          Jeżeli elementy nie są jednoznacznie umiejscowione w grid przez grid-area, grid-column, grid-row, itd., są one automatycznie umiejscowione według kolejności jaka znajduje się w kodzie źródłowym. Możemy to nadpisać z użyciee.<br>
          Domyślnie, wszystkie elementy grid mają wartość order ustawioną na 0, ale może to zostać ustawione na dowolną liczbę dodatnią lub ujemną, podobnie do atrybutu z-index.<br>
          Do tego pory, twój ogród składał się z siatki z pięcioma kolumnami, każda po 20% pełnej szerokości, pięciu rzędów, każdy po 20% pełnej wysokości.<br>
          To było zrobione według zasad grid-template-columns: 20% 20% 20% 20% 20%; i grid-template-rows: 20% 20% 20% 20% 20%; Każda zasada ma pięć wartości, które tworzą 5 kolumn - każda z nich tworzy 20% szerokości ogrodu.<br>
          Ale możesz ustawić siatkę w dowolny sposób. Ustaw nową wartość grid-template-columns, aby nawodnić swoje marchewki. Będziesz chciał ustawić szerokość pierwszej kolumny na 50%.<br>
          Definiowanie wielu kolumn o takiej samej szerokości może być nużące. Na szczęście istnieje funkcja repeat, która może nam w tym pomóc.<br>
          Na przykład, wcześniej zdefiniowaliśmy 5 kolumn o szerokości 20% przy pomocy zasady grid-template-columns: 20% 20% 20% 20% 20%;. To może być uproszczone jako grid-template-columns: repeat(5, 20%);<br>
          Używając grid-template-columns z funkcją repeat, stwórz 8 kolumn - każda po 12.5% szerokości. <br>
          grid-template-columns nie tylko akceptuje wartości podane w procentach, ale również jednostki takie jak pixele i em-y. Możesz nawet mieszać różne jednostki razem.<br>
          Ustaw odpowiednio wartości trzech kolumn na 100px, 3em i 40%.<br><br>
          
          Grid także wprowadza nową jednostkę, ułamek fr. Każda jednostka fr przyporządkowuje jedną część wolnej przestrzeni . Na przykład, jeżeli dwa elementy mają wartości odpowiednio 1fr i 3fr, przestrzeń jest podzielona na 4 równe części; pierwszy element zajmuje 1/4, a drugi element 3/4 pozostałej przestrzeni.<br>
          Kiedy kolumny mają wymiar podany w pixelach, procentach lub em-ach, każda inna kolumna podana w jednostce fr podzieli pozostałą przestrzeń.<br><br>
          
          grid-template-rows działa w podobny sposób jak grid-template-columns.<br>
          
          grid-template jest skróconą właściwością, która łączy grid-template-rows i grid-template-columns.<br>
          Na przykład, grid-template: 50% 50% / 200px; stworzy siatkę (grid) z dwoma wierszami każdy po 50%, i jedną kolumnę, która jest szeroka na 200 pixeli.
          .</p>
      </section>
    </main>
    <footer class="footer">
      Strona domowa Marcin Krygier. Powstała podczas szkolenia WTF. .
      <a class="footer__link" href="#top">Wróć na górę strony</a>
    </footer>
    <script src="main.js"></script>
  </body>
</html>
